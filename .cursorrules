You are an expert in TypeScript, Next.js 14 App Router, Tailwind CSS, shadcn, Framer Motion, and Lucide React.

**Code Style and Structure**

- Write concise, maintainable TypeScript code with accurate examples.
- Adopt functional and declarative programming patterns; avoid using classes unless necessary.
- Prioritize iteration and modularization to adhere to DRY principles and prevent code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., `isLoading`, `hasError`).
- Organize files systematically: each file should contain related content, such as exported components, subcomponents, helpers, static content, and types.

**Naming Conventions**

- Use lowercase with dashes for directory names (e.g., `components/auth-wizard`).
- Prefer named exports for components to facilitate easier imports and refactoring.

**TypeScript Usage**

- Utilize TypeScript for all code; prefer interfaces over types for their extendability and ability to merge.
- Avoid enums; use maps or union types instead for better type safety and flexibility.
- Implement functional components with TypeScript interfaces, ensuring proper typing of props and state.

**Syntax and Formatting**

- Use the `function` keyword for pure functions to enhance readability and maintainability.
- Avoid unnecessary curly braces in conditional statements; use concise syntax for simple statements.
- Adopt declarative JSX patterns to promote clarity and simplicity in component rendering.

**UI and Styling**

- Leverage shadcn and Tailwind CSS for component styling, ensuring a consistent and responsive design.
- Implement responsive design principles with Tailwind CSS, following a mobile-first approach.

**Animation**

- Utilize Framer Motion for animations, ensuring they are smooth and enhance user experience without hindering performance.
- Define animations in a way that they can be easily modified or extended, promoting reusability.

**Icons**

- Use Lucide React for icons, ensuring they are consistently styled and accessible.
- Optimize icon usage to prevent unnecessary rendering and improve performance.

**Performance Optimization**

- Minimize the use of `use client`, `useEffect`, and `setState`; favor React Server Components (RSC) where applicable.
- Wrap client components in `Suspense` with appropriate fallbacks to enhance loading states.
- Implement dynamic loading for non-critical components to improve initial load times.
- Optimize images by using modern formats like WebP, including size attributes, and implementing lazy loading.

**Security Practices**

- Sanitize all user inputs to prevent injection attacks.
- Implement proper authentication and authorization mechanisms, ensuring secure access control.
- Use environment variables for sensitive information and avoid hardcoding them in the codebase.
- Regularly update dependencies to patch known vulnerabilities.

**Testing**

- Write unit tests for all components and functions to ensure reliability and facilitate maintenance.
- Use testing libraries compatible with React and Next.js, such as Jest and React Testing Library.
- Implement end-to-end tests for critical user flows to ensure the application behaves as expected.

**Key Conventions**

1. Use `nuqs` for URL search parameter state management.
2. Optimize Web Vitals, including Largest Contentful Paint (LCP), Cumulative Layout Shift (CLS), and First Input Delay (FID).
3. Limit the use of `use client`:
   - Favor server components and Next.js SSR for rendering.
   - Use client components only for accessing Web APIs in isolated parts of the application.
   - Avoid using client components for data fetching or state management; prefer server-side solutions.

Follow the Next.js documentation for best practices on Data Fetching, Rendering, and Routing.

**State Management with Zustand**

- **Store Organization**:

  - Create separate stores for distinct application domains (e.g., `authStore`, `uiStore`, `dataStore`) to keep state modular and maintainable.
  - Use hooks like `useAuthStore` or `useUIStore` to access state, ensuring encapsulation.

- **Type Safety**:

  - Use TypeScript to define the shape of each store, including the state and actions.
  - Example:

    ```typescript
    import create from "zustand";

    interface AuthState {
      isAuthenticated: boolean;
      user: { id: string; name: string } | null;
      login: (user: { id: string; name: string }) => void;
      logout: () => void;
    }

    export const useAuthStore = create<AuthState>((set) => ({
      isAuthenticated: false,
      user: null,
      login: (user) => set({ isAuthenticated: true, user }),
      logout: () => set({ isAuthenticated: false, user: null }),
    }));
    ```

- **State Mutations**:

  - Use **`set`** and **`get`** responsibly:
    - Avoid direct mutations. Always use `set()` to update the state for better readability and debugging.
    - For derived state, use selectors to compute values without bloating the store.

- **Selectors**:

  - Optimize re-renders by using selectors to retrieve specific slices of the state.
  - Example:
    ```typescript
    const userName = useAuthStore((state) => state.user?.name);
    ```

- **Persisted State**:

  - Use Zustand's `persist` middleware to save and rehydrate state across sessions where needed (e.g., user preferences or auth tokens).
  - Example:

    ```typescript
    import { persist } from "zustand/middleware";

    export const useSettingsStore = create(
      persist(
        (set) => ({
          theme: "light",
          setTheme: (theme: "light" | "dark") => set({ theme }),
        }),
        { name: "settings-storage" }
      )
    );
    ```

- **Middleware**:

  - Incorporate middleware like logging for debugging or devtools for better state inspection during development.
  - Example:

    ```typescript
    import { devtools } from "zustand/middleware";

    const useStore = create(
      devtools((set) => ({
        count: 0,
        increment: () => set((state) => ({ count: state.count + 1 })),
      }))
    );
    ```

- **Immutable State**:

  - Ensure that state updates are always immutable. Zustand supports this by default, but be cautious with objects or arrays.
  - Use utilities like `produce` from `immer` if needed for complex updates.

- **Error Handling**:

  - Handle errors within actions and update the store accordingly (e.g., an `error` state for API calls).

- **Integration with Framer Motion and UI**:

  - Store UI state such as modal visibility or animation triggers in Zustand for easy synchronization with Framer Motion components.
  - Example:
    ```typescript
    const isModalOpen = useUIStore((state) => state.isModalOpen);
    ```

- **Testing State**:
  - Write unit tests for stores, mocking Zustand's `set` and `get` functions to simulate state updates.
  - Example:
    ```typescript
    const { result } = renderHook(() => useAuthStore());
    act(() => result.current.login({ id: "123", name: "John Doe" }));
    expect(result.current.user).toEqual({ id: "123", name: "John Doe" });
    ```

**Key Conventions**

1. Prefer Zustand over React context for non-global state to prevent unnecessary re-renders.
2. Avoid deeply nested state; flatten your store to keep state updates efficient and predictable.
3. Use a single source of truth by storing all derived or computed state in selectors instead of directly in the store.

By following these rules, your integration with Zustand will remain clean, efficient, and aligned with your project's top-notch standards. It also ensures your state management remains scalable as the application grows.```
